// Generated by CoffeeScript 1.4.0
(function() {
  var Cartograph, exports;

  Cartograph = (function() {
    var extractParamNames, param_regexp, parseQueryParams, routeToParamRegExp, routeToRegexp, routeToSplatRegExp, splat_regexp;

    param_regexp = /:([\w\d]+)/g;

    splat_regexp = /\*/g;

    routeToParamRegExp = function(route) {
      var param_replace, splat_replace;
      param_replace = "([^\/]+)";
      splat_replace = ".*";
      return routeToRegexp(route, param_replace, splat_replace);
    };

    routeToSplatRegExp = function(route) {
      var param_replace, splat_replace;
      param_replace = "[^\/]+";
      splat_replace = "(.*)";
      return routeToRegexp(route, param_replace, splat_replace);
    };

    routeToRegexp = function(route, param_replace, splat_replace) {
      var escape_regexp;
      escape_regexp = /[\-{}\[\]+?.,\\\^$|#\s]/g;
      route = route.replace(escape_regexp, "\\$&").replace(param_regexp, param_replace).replace(splat_regexp, splat_replace);
      return new RegExp("^" + route + "$", "i");
    };

    extractParamNames = function(route) {
      var name, name_regexp, names, _results;
      name_regexp = /[:|\*]([\w\d]+)/g;
      _results = [];
      while (name = name_regexp.exec(route)) {
        _results.push(names = name[1]);
      }
      return _results;
    };

    parseQueryParams = function(querystr) {
      var match, params, re;
      params = {};
      if (querystr != null) {
        re = /[\?&]([^=&]+)=?([^&$]+)?/g;
        while (match = re.exec(querystr)) {
          params[match[1]] = match[2];
        }
      }
      return params;
    };

    function Cartograph(fn) {
      if (typeof fn === "function") {
        this.draw(fn);
      }
    }

    Cartograph.prototype.draw = function(fn) {
      return fn.call(this);
    };

    Cartograph.prototype.map = function(route, fn) {
      var _ref;
      if ((_ref = this.mappings) == null) {
        this.mappings = [];
      }
      if (typeof route !== "string") {
        throw new Error("route must be a string");
      }
      if (typeof fn !== "function") {
        throw new Error("callback must be a function");
      }
      return this.mappings.push({
        route: route,
        callback: fn
      });
    };

    Cartograph.prototype.match = function(msg, mixin) {
      var key, mapping, match, params, val, _i, _len, _ref, _results;
      _ref = this.mappings;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        mapping = _ref[_i];
        if (match = this.scan(msg, mapping.route)) {
          if (mixin != null) {
            params = mixin.params;
            delete mixin.params;
            for (key in mixin) {
              val = mixin[key];
              match[key] = val;
            }
            if ((params != null) && !(match.params != null)) {
              match.params = params;
            } else {
              for (key in params) {
                val = params[key];
                match.params[key] = val;
              }
            }
          }
          mapping.callback(match);
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Cartograph.prototype.matchLocation = function(loc) {
      var key, mixin, val;
      if (loc == null) {
        loc = window.location;
      }
      mixin = {};
      if (loc.search != null) {
        mixin.params = parseQueryParams(loc.search);
      }
      for (key in loc) {
        val = loc[key];
        mixin[key] = val;
      }
      return this.match(loc.pathname, mixin);
    };

    Cartograph.prototype.scan = function(msg, route, mapping) {
      var i, match, name, param_data, param_names, param_re, params, splat_data, splat_re, _i, _len;
      if (mapping == null) {
        mapping = {};
      }
      param_re = mapping.param_regexp || routeToParamRegExp(route);
      mapping.param_regexp = param_re;
      if (!param_re.test(msg)) {
        return false;
      }
      splat_re = mapping.splat_regexp || routeToSplatRegExp(route);
      mapping.splat_regexp = splat_re;
      param_data = param_re.exec(msg);
      splat_data = splat_re.exec(msg);
      param_names = mapping.param_names || extractParamNames(route);
      mapping.param_names = param_names;
      params = {};
      for (i = _i = 0, _len = param_names.length; _i < _len; i = ++_i) {
        name = param_names[i];
        params[name] = param_data[i + 1];
      }
      params.splats = splat_data.slice(1);
      return match = {
        params: params
      };
    };

    Cartograph.prototype.namespace = function(ns, fn) {
      var proxy, self;
      self = this;
      proxy = {
        map: function(route, cbk) {
          return self.map(ns + route, cbk);
        }
      };
      return fn.call(proxy);
    };

    return Cartograph;

  })();

  if (typeof exports !== "undefined" && exports !== null) {
    if ((typeof module !== "undefined" && module !== null) && (module.exports != null)) {
      exports = module.exports = Cartograph;
    }
    exports.Cartograph = Cartograph;
  } else if (typeof define === "function" && define.amd) {
    define(function() {
      return Cartograph;
    });
  } else {
    this.Cartograph = Cartograph;
  }

}).call(this);
