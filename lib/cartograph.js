// Generated by CoffeeScript 1.4.0
(function() {
  var Cartograph, exports;

  Cartograph = (function() {
    var decode, extractParamNames, lastElemOf, param_regexp, param_replace, parseQueryParams, routeToRegExp, setNestedParam, splat_regexp, splat_replace;

    param_regexp = /:([\w\d]+)/g;

    splat_regexp = /\*\w+/g;

    param_replace = "([^\/]+)";

    splat_replace = "(.*)";

    routeToRegExp = function(route) {
      var escape_regexp;
      escape_regexp = /[\-{}\[\]+?.,\\\^$|#\s]/g;
      route = route.replace(escape_regexp, "\\$&").replace(param_regexp, param_replace).replace(splat_regexp, splat_replace);
      return new RegExp("^" + route + "$", "i");
    };

    extractParamNames = function(route) {
      var name, name_regexp, names, _results;
      name_regexp = /[:|\*]([\w\d]+)/g;
      _results = [];
      while (name = name_regexp.exec(route)) {
        _results.push(names = name[1]);
      }
      return _results;
    };

    setNestedParam = function(obj, nesting, value, overwrite) {
      var last_part, part, part_regexp, parts, root, root_regexp, _i, _len, _ref, _ref1;
      if (overwrite == null) {
        overwrite = true;
      }
      part_regexp = /\[([^\]]+)\]/g;
      root_regexp = /^([^\[]+)(\[|$)/;
      root = (_ref = root_regexp.exec(nesting)) != null ? _ref[1] : void 0;
      parts = [root];
      while (part = part_regexp.exec(nesting)) {
        parts.push(part[1]);
      }
      last_part = parts.pop();
      for (_i = 0, _len = parts.length; _i < _len; _i++) {
        part = parts[_i];
        if ((_ref1 = obj[part]) == null) {
          obj[part] = {};
        }
        obj = obj[part];
      }
      if (overwrite || !(obj[last_part] != null)) {
        obj[last_part] = value;
      }
      return obj[last_part];
    };

    parseQueryParams = function(querystr) {
      var k, match, name, param, params, re, _i;
      params = {};
      if (querystr != null) {
        re = /[\?&]([^=&]+)=?([^&$]+)?/g;
        while (match = re.exec(querystr)) {
          for (k = _i = 1; _i <= 2; k = ++_i) {
            if (match[k] != null) {
              match[k] = decode(match[k]);
            }
          }
          if (/\[\]$/.test(match[1])) {
            name = match[1].replace(/\[\]$/, "");
            param = setNestedParam(params, name, [], false);
            param.push(match[2]);
          } else {
            setNestedParam(params, match[1], match[2]);
          }
        }
      }
      return params;
    };

    lastElemOf = function(array) {
      return array[array.length - 1];
    };

    decode = function(v) {
      if (v == null) {
        return v;
      }
      return decodeURIComponent(v.replace(/\+/g, "%20"));
    };

    function Cartograph(fn) {
      if (typeof fn === "function") {
        this.draw(fn);
      }
    }

    Cartograph.prototype.draw = function(fn) {
      return fn.call(this);
    };

    Cartograph.prototype.map = function(route, fn) {
      var prefixed_route, _ref, _ref1;
      if ((_ref = this.mappings) == null) {
        this.mappings = [];
      }
      if (typeof route !== "string") {
        throw new Error("route must be a string");
      }
      if (typeof fn !== "function") {
        throw new Error("callback must be a function");
      }
      if ((_ref1 = this._prefix_stack) == null) {
        this._prefix_stack = [];
      }
      prefixed_route = (lastElemOf(this._prefix_stack) || "") + route;
      return this.mappings.push({
        route: prefixed_route,
        callback: fn
      });
    };

    Cartograph.prototype.route = function(path, mixin) {
      var key, mapping, match, params, val, _i, _len, _ref;
      _ref = this.mappings;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        mapping = _ref[_i];
        if (match = this.scan(path, mapping.route)) {
          if (mixin != null) {
            params = mixin.params;
            delete mixin.params;
            for (key in mixin) {
              val = mixin[key];
              match[key] = val;
            }
            if ((params != null) && !(match.params != null)) {
              match.params = params;
            } else {
              for (key in params) {
                val = params[key];
                match.params[key] = val;
              }
            }
          }
          return mapping.callback(match);
        }
      }
      return null;
    };

    Cartograph.prototype.routeRequest = function(req) {
      var key, mixin, val;
      if (req == null) {
        req = window.location;
      }
      mixin = {};
      if (req.search != null) {
        mixin.params = parseQueryParams(req.search);
      }
      for (key in req) {
        val = req[key];
        mixin[key] = val;
      }
      return this.route(req.pathname, mixin);
    };

    Cartograph.prototype.scan = function(path, route, mapping) {
      var data, i, match, name, params, _i, _len, _ref;
      if (mapping == null) {
        mapping = {};
      }
      mapping.regexp = mapping.regexp || routeToRegExp(route);
      if (!mapping.regexp.test(path)) {
        return false;
      }
      data = mapping.regexp.exec(path);
      mapping.param_names = mapping.param_names || extractParamNames(route);
      params = {};
      _ref = mapping.param_names;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        name = _ref[i];
        params[name] = decode(data[i + 1]);
      }
      return match = {
        params: params
      };
    };

    Cartograph.prototype.namespace = function(ns, fn) {
      var _ref;
      if ((_ref = this._prefix_stack) == null) {
        this._prefix_stack = [];
      }
      this._prefix_stack.push((lastElemOf(this._prefix_stack) || "") + ns);
      fn.call(this);
      return this._prefix_stack.pop();
    };

    return Cartograph;

  })();

  if (typeof exports !== "undefined" && exports !== null) {
    if ((typeof module !== "undefined" && module !== null) && (module.exports != null)) {
      exports = module.exports = Cartograph;
    }
    exports.Cartograph = Cartograph;
  } else if (typeof define === "function" && define.amd) {
    define(function() {
      return Cartograph;
    });
  } else {
    this.Cartograph = Cartograph;
  }

}).call(this);
